11 散列表

### 11.1 直接寻址表

> 1.为表示动态集合，我们用一个数组，或称为直接寻址表(direct-address table),记为T[0..m-1].<br/>
> 2.其中每个位置，或称为槽(slot)，对应全域U中的一个关键字。<br/>
> 3.槽k指向集合中一个关键字为k的元素。如果该集合中没有关键字为k的元素，则T[k]=NIL<br/>


![avatar](images/01_direct_address_structure.jpg)

```

DIRECT-ADDRESS-SEARCH(T,k)
return T[k]

DIRECT-ADDRESS-INSERT(T,x)
T[x.key]=x

DIRECT-ADDRESS-DELEETE(T,x)
T[x.key]=NIL

```

> 上述每个操作都只需要O(1)时间<br/>

### 11.2 散列表

> 1.直接寻址技术的缺陷：如果全域U很大，实际存储的关键自己和K相对U来说可能很小，使得存储U的大部分空间都将浪费<br/>
> 2.在散列方式下，该元素存放在槽h(k)中；即散列函数(hash function)h,由关键字k计算出槽的位置。函数h将全域U映射到散列表(hash table)T[0..m-1]的槽位上，m一般比|U|小很多。<br/>
> 3.存在问题:两个关键字可能映射到同一个槽位中。这个情形为冲突<br/>


![avatar](images/02_hash_table_structure.jpg)

> 4.解约冲突的方法：链接法和开放寻址法<br/>
> 5.链接法：把散列到同一个槽中的所有元素都放在同一个链表中，槽j中有一个指针，它指向存储所有散列到j的元素的链表的表头；如果不存在这样元素，则槽j中为NIL<br/>

![avatar](images/03_hash_collision_chaining.jpg)


### 11.3 散列函数

> 1.好的散列函数的特点：满足简单均匀散列假设：每个关键字都被等可能地散列到m个槽位中的任何一个，并与其他关键字已散列到那个槽位无关<br/>
> 2.将关键字转换为自然数：需要找到一种方法将关键字转换为自然数。<br/>

#### 11.3.1 除法散列法

> 1.散列函数: h(k) = k mod m <br/>
> 2.注意m的选值，不应为2的幂，一般一个不太接近2的整数幂的素数，常常是m的一个较好的选择。<br/>

#### 11.3.2 乘法散列法

> 1.乘法散列2步骤：<br/>
    (1) 关键字k乘以常熟A(0 < A < 1)，并提取kA的小数部分，<br/>
    (2) 用m乘以这个值，再向下取整，公式如下：<br/>
    h(k) = |m(kA mod 1)|<br/>
> 2.乘法散列法的优点对m的选择不是特别关键，一般选择它为2的某个幂次(2^p,p为整数)
     
#### 11.3.3 全域散列法

> 1.由于会现所有的关键字全部散列到同一个槽的糟糕情况，有效的改进方法是随机地选择散列函数，使之独立于要存储的关键字，这种方法为全域散列
> 2.设H为一组有限散列函数，它将给定的关键字全域U映射到{0,1,...,m-1}中。这样的函数称作<strong font-color="red">全域的</strong>
> 3.
     
